(self.webpackChunkceph_dashboard=self.webpackChunkceph_dashboard||[]).push([[6201],{26201:(b,f,_)=>{_.r(f),_.d(f,{E_ALREADY_LOCKED:()=>m,E_CANCELED:()=>p,E_TIMEOUT:()=>w,Mutex:()=>A,Semaphore:()=>v,tryAcquire:()=>T,withTimeout:()=>q});const w=new Error("timeout while waiting for mutex to become available"),m=new Error("mutex already locked"),p=new Error("request for lock canceled");class v{constructor(e,t=p){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((i,o)=>{const n={resolve:i,reject:o,weight:e,priority:t},u=E(this._queue,a=>t<=a.priority);-1===u&&e<=this._value?this._dispatchItem(n):this._queue.splice(u+1,0,n)})}runExclusive(e){return function(r,e,t,i){return new(t||(t=Promise))(function(n,u){function a(s){try{c(i.next(s))}catch(l){u(l)}}function h(s){try{c(i.throw(s))}catch(l){u(l)}}function c(s){s.done?n(s.value):function o(n){return n instanceof t?n:new t(function(u){u(n)})}(s.value).then(a,h)}c((i=i.apply(r,e||[])).next())})}(this,arguments,void 0,function*(t,i=1,o=0){const[n,u]=yield this.acquire(i,o);try{return yield t(n)}finally{u()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(i=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),function x(r,e){const t=E(r,i=>e.priority<=i.priority);r.splice(t+1,0,e)}(this._weightedWaiters[e-1],{resolve:i,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(0===this._queue.length)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(i=>i.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const i=this._weightedWaiters[t-1];if(!i)continue;const o=i.findIndex(n=>n.priority<=e);(-1===o?i:i.splice(0,o)).forEach(n=>n.resolve())}}}_couldLockImmediately(e,t){return(0===this._queue.length||this._queue[0].priority<t)&&e<=this._value}}function E(r,e){for(let t=r.length-1;t>=0;t--)if(e(r[t]))return t;return-1}class A{constructor(e){this._semaphore=new v(1,e)}acquire(){return r=this,e=arguments,i=function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t},new((t=void 0)||(t=Promise))(function(n,u){function a(s){try{c(i.next(s))}catch(l){u(l)}}function h(s){try{c(i.throw(s))}catch(l){u(l)}}function c(s){s.done?n(s.value):function o(n){return n instanceof t?n:new t(function(u){u(n)})}(s.value).then(a,h)}c((i=i.apply(r,e||[])).next())});var r,e,t,i}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var k=function(r,e,t,i){return new(t||(t=Promise))(function(n,u){function a(s){try{c(i.next(s))}catch(l){u(l)}}function h(s){try{c(i.throw(s))}catch(l){u(l)}}function c(s){s.done?n(s.value):function o(n){return n instanceof t?n:new t(function(u){u(n)})}(s.value).then(a,h)}c((i=i.apply(r,e||[])).next())})};function q(r,e,t=w){return{acquire:(i,o)=>{let n;if(d(r)?n=i:(n=void 0,o=i),void 0!==n&&n<=0)throw new Error(`invalid weight ${n}: must be positive`);return new Promise((u,a)=>k(this,void 0,void 0,function*(){let h=!1;const c=setTimeout(()=>{h=!0,a(t)},e);try{const s=yield d(r)?r.acquire(n,o):r.acquire(o);h?(Array.isArray(s)?s[1]:s)():(clearTimeout(c),u(s))}catch(s){h||(clearTimeout(c),a(s))}}))},runExclusive(i,o,n){return k(this,void 0,void 0,function*(){let u=()=>{};try{const a=yield this.acquire(o,n);return Array.isArray(a)?(u=a[1],yield i(a[0])):(u=a,yield i())}finally{u()}})},release(i){r.release(i)},cancel:()=>r.cancel(),waitForUnlock:(i,o)=>{let n;if(d(r)?n=i:(n=void 0,o=i),void 0!==n&&n<=0)throw new Error(`invalid weight ${n}: must be positive`);return new Promise((u,a)=>{const h=setTimeout(()=>a(t),e);(d(r)?r.waitForUnlock(n,o):r.waitForUnlock(o)).then(()=>{clearTimeout(h),u()})})},isLocked:()=>r.isLocked(),getValue:()=>r.getValue(),setValue:i=>r.setValue(i)}}function d(r){return void 0!==r.getValue}function T(r,e=m){return q(r,0,e)}}}]);