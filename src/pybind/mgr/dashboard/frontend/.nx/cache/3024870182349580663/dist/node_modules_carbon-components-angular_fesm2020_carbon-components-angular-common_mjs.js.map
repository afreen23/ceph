{"version":3,"file":"node_modules_carbon-components-angular_fesm2020_carbon-components-angular-common_mjs.js","mappings":"idAAA,IAAIA,EAAmB,4RAInBC,EAAiC,mLAIrC,SAASC,EAAoBC,EAASC,EAAWJ,GAC7C,IAAIK,EAAWF,EAAQG,iBAAiBF,GACxC,OAAOC,GAAWE,MAAMC,UAAUC,OAAOC,KAAKL,EAAUM,GAAMC,EAAUD,GAC5E,CACA,SAASE,EAAmBC,EAAOC,GAC/B,OAAIA,EAAKC,OAAS,IACNF,EAAMG,QAAUH,EAAMI,cAAgBH,EAAK,EAG3D,CACA,SAASI,EAAkBL,EAAOC,GAC9B,OAAIA,EAAKC,OAAS,IACNF,EAAMG,QAAUH,EAAMI,cAAgBH,EAAKA,EAAKC,OAAS,EAGzE,CACA,SAASI,EAAiBN,EAAOX,GAC7B,OAAQW,EAAMG,QAAUH,EAAMI,cAAgBf,CAClD,CACA,SAASkB,EAA2BN,GAChC,OAAIA,EAAKC,OAAS,IACdD,EAAK,GAAGO,SACD,EAGf,CACA,SAASC,EAA0BR,GAC/B,OAAIA,EAAKC,OAAS,IACdD,EAAKA,EAAKC,OAAS,GAAGM,SACf,EAGf,CACA,SAASV,EAAUT,GACf,SAAUA,EAAQqB,aAAerB,EAAQsB,cAAgBtB,EAAQuB,iBAAiBV,OACtF,CACA,SAASW,EAAUb,EAAOX,GACtB,GAAkB,QAAdW,EAAMc,IAAe,CACrB,IAAIb,EAAOb,EAAoBC,GAC3B0B,GAAe,EACff,EAAMgB,UACFjB,EAAmBC,EAAOC,IAASK,EAAiBN,EAAOX,MAC3D0B,EAAeN,EAA0BR,IAIzCI,EAAkBL,EAAOC,KACzBc,EAAeR,EAA2BN,IAG9Cc,IACAf,EAAMiB,iBACNjB,EAAMkB,kBAEd,CACJ,CAeA,SAASC,EAAMC,EAAMC,EAAQ,EAAGC,EAAO,GACnC,OAAO7B,MAAM8B,KAAKC,MAAMJ,EAAOC,GAASC,IAAOG,KAAK,GAAGC,IAAI,CAACC,EAAGC,IAAMA,EAAIN,EAAOD,EACpF","names":["tabbableSelector","tabbableSelectorIgnoreTabIndex","getFocusElementList","element","selector","elements","querySelectorAll","Array","prototype","filter","call","el","isVisible","isFocusInFirstItem","event","list","length","target","srcElement","isFocusInLastItem","isElementFocused","focusFirstFocusableElement","focus","focusLastFocusableElement","offsetWidth","offsetHeight","getClientRects","cycleTabs","key","focusChanged","shiftKey","preventDefault","stopPropagation","range","stop","start","step","Math","ceil","fill","map","x","i"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/carbon-components-angular/fesm2020/carbon-components-angular-common.mjs"],"sourcesContent":["let tabbableSelector = \"a[href], area[href], input:not([disabled]):not([tabindex=\\'-1\\']), \" +\n    \"button:not([disabled]):not([tabindex=\\'-1\\']),select:not([disabled]):not([tabindex=\\'-1\\']), \" +\n    \"textarea:not([disabled]):not([tabindex=\\'-1\\']), \" +\n    \"iframe, object, embed, *[tabindex]:not([tabindex=\\'-1\\']), *[contenteditable=true]\";\nlet tabbableSelectorIgnoreTabIndex = \"a[href], area[href], input:not([disabled]), \" +\n    \"button:not([disabled]),select:not([disabled]), \" +\n    \"textarea:not([disabled]), \" +\n    \"iframe, object, embed, *[tabindex], *[contenteditable=true]\";\nfunction getFocusElementList(element, selector = tabbableSelector) {\n    let elements = element.querySelectorAll(selector);\n    return elements ? Array.prototype.filter.call(elements, el => isVisible(el)) : elements;\n}\nfunction isFocusInFirstItem(event, list) {\n    if (list.length > 0) {\n        return (event.target || event.srcElement) === list[0];\n    }\n    return false;\n}\nfunction isFocusInLastItem(event, list) {\n    if (list.length > 0) {\n        return (event.target || event.srcElement) === list[list.length - 1];\n    }\n    return false;\n}\nfunction isElementFocused(event, element) {\n    return (event.target || event.srcElement) === element;\n}\nfunction focusFirstFocusableElement(list) {\n    if (list.length > 0) {\n        list[0].focus();\n        return true;\n    }\n    return false;\n}\nfunction focusLastFocusableElement(list) {\n    if (list.length > 0) {\n        list[list.length - 1].focus();\n        return true;\n    }\n    return false;\n}\nfunction isVisible(element) {\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\nfunction cycleTabs(event, element) {\n    if (event.key === \"Tab\") {\n        let list = getFocusElementList(element);\n        let focusChanged = false;\n        if (event.shiftKey) {\n            if (isFocusInFirstItem(event, list) || isElementFocused(event, element)) {\n                focusChanged = focusLastFocusableElement(list);\n            }\n        }\n        else {\n            if (isFocusInLastItem(event, list)) {\n                focusChanged = focusFirstFocusableElement(list);\n            }\n        }\n        if (focusChanged) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n}\n\n/**\n * Does what python's `range` function does, with a slightly different\n * signature because of Typescript limitations.\n *\n * Useful for numbered loops in angular templates, since we can do\n * a normal for loop.\n *\n * @export\n * @param stop Generate numbers up to, but not including this number\n * @param [start=0] Starting number of the sequence\n * @param [step=1] Difference between each number in the sequence\n * @returns an array with resulting numbers\n */\nfunction range(stop, start = 0, step = 1) {\n    return Array(Math.ceil((stop - start) / step)).fill(0).map((x, i) => i * step + start);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cycleTabs, focusFirstFocusableElement, focusLastFocusableElement, getFocusElementList, isElementFocused, isFocusInFirstItem, isFocusInLastItem, isVisible, range, tabbableSelector, tabbableSelectorIgnoreTabIndex };\n"],"x_google_ignoreList":[0]}