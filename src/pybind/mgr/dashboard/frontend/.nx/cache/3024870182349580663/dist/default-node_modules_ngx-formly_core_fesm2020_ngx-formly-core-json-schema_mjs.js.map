{"version":3,"file":"default-node_modules_ngx-formly_core_fesm2020_ngx-formly-core-json-schema_mjs.js","mappings":"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","names":["isEmpty","v","isObject","Array","isArray","isInteger","value","Number","Math","floor","isConst","schema","hasOwnProperty","enum","length","totalMatchedFields","field","fieldGroup","ɵhasKey","undefined","ɵgetFieldValue","total","reduce","s","f","fieldArray","FormlyJsonschema","toFieldConfig","options","this","_toFieldConfig","key","resolveSchema","types","guessSchemaType","type","defaultValue","default","props","label","title","readonly","readOnly","description","ignoreDefault","disabled","resetOnHide","strict","addValidator","c","shareFormControl","schemaType","expression","indexOf","parsers","min","minimum","max","maximum","exclusiveMinimum","exclusiveMaximum","step","multipleOf","multiplier","pow","decimalPlaces","a","isFinite","e","p","round","required","forEach","prop","propDeps","schemaDeps","resolveDependencies","Object","keys","properties","property","isRequired","isOptional","push","expressions","parent","model","some","k","getConstValue","const","oneOfSchema","oneOf","every","o","oneOfSchemaItem","u","constSchema","hide","resolveMultiSchema","anyOf","minItems","from","maxItems","uniqueItems","Set","map","JSON","stringify","items","isEnum","root","itemSchema","additionalItems","removable","multiple","toEnumOptions","widget","formlyConfig","mergeFields","templateOptions","$ref","resolveDefinition","allOf","resolveAllOf","baseSchema","Error","base","ɵreverseDeepMerge","mode","schemas","i","hooks","onInit","formControl","valueChanges","pipe","tap","detectChanges","forceUpdate","control","isFieldValid","sort","f1","f1Valid","f2","f2Valid","matchedFields1","matchedFields2","definedValue","filter","setValue","uri","pointer","split","definition","def","path","annotation","dependencies","dependency","dep","t1","name","validator","validators","toEnum","option","_schemasFields","defineProperty","enumerable","writable","configurable","ɵclone","build","form","FormArray","FormGroup","valid","f1Prop","ɵfac","__ngFactoryType__","ɵprov","i0","token","factory","providedIn"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core-json-schema.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport { FormArray, FormGroup } from '@angular/forms';\nimport { ɵhasKey, ɵgetFieldValue, ɵreverseDeepMerge, ɵclone } from '@ngx-formly/core';\nimport { tap } from 'rxjs/operators';\n\n// https://stackoverflow.com/a/27865285\nfunction decimalPlaces(a) {\n    if (!isFinite(a)) {\n        return 0;\n    }\n    let e = 1, p = 0;\n    while (Math.round(a * e) / e !== a) {\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction isEmpty(v) {\n    return v === '' || v == null;\n}\nfunction isObject(v) {\n    return v != null && typeof v === 'object' && !Array.isArray(v);\n}\nfunction isInteger(value) {\n    return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && Math.floor(value) === value;\n}\nfunction isConst(schema) {\n    return typeof schema === 'object' && (schema.hasOwnProperty('const') || (schema.enum && schema.enum.length === 1));\n}\nfunction totalMatchedFields(field) {\n    if (!field.fieldGroup) {\n        return ɵhasKey(field) && ɵgetFieldValue(field) !== undefined ? 1 : 0;\n    }\n    const total = field.fieldGroup.reduce((s, f) => totalMatchedFields(f) + s, 0);\n    if (total === 0 && ɵhasKey(field)) {\n        const value = ɵgetFieldValue(field);\n        if (value === null ||\n            (value !== undefined && ((field.fieldArray && Array.isArray(value)) || (!field.fieldArray && isObject(value))))) {\n            return 1;\n        }\n    }\n    return total;\n}\nclass FormlyJsonschema {\n    toFieldConfig(schema, options) {\n        return this._toFieldConfig(schema, { schema, ...(options || {}) });\n    }\n    _toFieldConfig(schema, { key, ...options }) {\n        schema = this.resolveSchema(schema, options);\n        const types = this.guessSchemaType(schema);\n        let field = {\n            type: types[0],\n            defaultValue: schema.default,\n            props: {\n                label: schema.title,\n                readonly: schema.readOnly,\n                description: schema.description,\n            },\n        };\n        if (key != null) {\n            field.key = key;\n        }\n        if (!options.ignoreDefault && (schema.readOnly || options.readOnly)) {\n            field.props.disabled = true;\n            options = { ...options, readOnly: true };\n        }\n        if (options.resetOnHide) {\n            field.resetOnHide = true;\n        }\n        if (key && options.strict) {\n            this.addValidator(field, 'type', (c, f) => {\n                const value = ɵgetFieldValue(f);\n                if (value != null) {\n                    switch (field.type) {\n                        case 'string': {\n                            return typeof value === 'string';\n                        }\n                        case 'integer': {\n                            return isInteger(value);\n                        }\n                        case 'number': {\n                            return typeof value === 'number';\n                        }\n                        case 'object': {\n                            return isObject(value);\n                        }\n                        case 'array': {\n                            return Array.isArray(value);\n                        }\n                    }\n                }\n                return true;\n            });\n        }\n        if (options.shareFormControl === false) {\n            field.shareFormControl = false;\n        }\n        if (options.ignoreDefault) {\n            delete field.defaultValue;\n        }\n        this.addValidator(field, 'type', {\n            schemaType: types,\n            expression: ({ value }) => {\n                if (value === undefined) {\n                    return true;\n                }\n                if (value === null && types.indexOf('null') !== -1) {\n                    return true;\n                }\n                switch (types[0]) {\n                    case 'null': {\n                        return typeof value === null;\n                    }\n                    case 'string': {\n                        return typeof value === 'string';\n                    }\n                    case 'integer': {\n                        return isInteger(value);\n                    }\n                    case 'number': {\n                        return typeof value === 'number';\n                    }\n                    case 'object': {\n                        return isObject(value);\n                    }\n                    case 'array': {\n                        return Array.isArray(value);\n                    }\n                }\n                return true;\n            },\n        });\n        switch (field.type) {\n            case 'number':\n            case 'integer': {\n                field.parsers = [(v) => (isEmpty(v) ? undefined : Number(v))];\n                if (schema.hasOwnProperty('minimum')) {\n                    field.props.min = schema.minimum;\n                }\n                if (schema.hasOwnProperty('maximum')) {\n                    field.props.max = schema.maximum;\n                }\n                if (schema.hasOwnProperty('exclusiveMinimum')) {\n                    field.props.exclusiveMinimum = schema.exclusiveMinimum;\n                    this.addValidator(field, 'exclusiveMinimum', ({ value }) => isEmpty(value) || value > schema.exclusiveMinimum);\n                }\n                if (schema.hasOwnProperty('exclusiveMaximum')) {\n                    field.props.exclusiveMaximum = schema.exclusiveMaximum;\n                    this.addValidator(field, 'exclusiveMaximum', ({ value }) => isEmpty(value) || value < schema.exclusiveMaximum);\n                }\n                if (schema.hasOwnProperty('multipleOf')) {\n                    field.props.step = schema.multipleOf;\n                    this.addValidator(field, 'multipleOf', ({ value }) => {\n                        if (isEmpty(value) || typeof value !== 'number' || value === 0 || schema.multipleOf <= 0) {\n                            return true;\n                        }\n                        // https://github.com/ajv-validator/ajv/issues/652#issue-283610859\n                        const multiplier = Math.pow(10, decimalPlaces(schema.multipleOf));\n                        return Math.round(value * multiplier) % Math.round(schema.multipleOf * multiplier) === 0;\n                    });\n                }\n                break;\n            }\n            case 'string': {\n                field.parsers = [\n                    (v) => {\n                        if (types.indexOf('null') !== -1) {\n                            v = isEmpty(v) ? null : v;\n                        }\n                        else if (!field.props.required) {\n                            v = v === '' ? undefined : v;\n                        }\n                        return v;\n                    },\n                ];\n                ['minLength', 'maxLength', 'pattern'].forEach((prop) => {\n                    if (schema.hasOwnProperty(prop)) {\n                        field.props[prop] = schema[prop];\n                    }\n                });\n                break;\n            }\n            case 'object': {\n                if (!field.fieldGroup) {\n                    field.fieldGroup = [];\n                }\n                const { propDeps, schemaDeps } = this.resolveDependencies(schema);\n                Object.keys(schema.properties || {}).forEach((property) => {\n                    const isRequired = Array.isArray(schema.required) && schema.required.indexOf(property) !== -1;\n                    const f = this._toFieldConfig(schema.properties[property], {\n                        ...options,\n                        key: property,\n                        isOptional: options.isOptional || !isRequired,\n                    });\n                    field.fieldGroup.push(f);\n                    if (isRequired || propDeps[property]) {\n                        f.expressions = {\n                            ...(f.expressions || {}),\n                            'props.required': (f) => {\n                                let parent = f.parent;\n                                const model = f.fieldGroup && f.key != null ? parent.model : f.model;\n                                while (parent.key == null && parent.parent) {\n                                    parent = parent.parent;\n                                }\n                                const required = parent && parent.props ? parent.props.required : false;\n                                if (!model && !required) {\n                                    return false;\n                                }\n                                if (Array.isArray(schema.required) && schema.required.indexOf(property) !== -1) {\n                                    return true;\n                                }\n                                return propDeps[property] && f.model && propDeps[property].some((k) => !isEmpty(f.model[k]));\n                            },\n                        };\n                    }\n                    if (schemaDeps[property]) {\n                        const getConstValue = (s) => {\n                            return s.hasOwnProperty('const') ? s.const : s.enum[0];\n                        };\n                        const oneOfSchema = schemaDeps[property].oneOf;\n                        if (oneOfSchema &&\n                            oneOfSchema.every((o) => o.properties && o.properties[property] && isConst(o.properties[property]))) {\n                            oneOfSchema.forEach((oneOfSchemaItem) => {\n                                const { [property]: constSchema, ...properties } = oneOfSchemaItem.properties;\n                                field.fieldGroup.push({\n                                    ...this._toFieldConfig({ ...oneOfSchemaItem, properties }, { ...options, resetOnHide: true }),\n                                    expressions: {\n                                        hide: (f) => !f.model || getConstValue(constSchema) !== f.model[property],\n                                    },\n                                });\n                            });\n                        }\n                        else {\n                            field.fieldGroup.push({\n                                ...this._toFieldConfig(schemaDeps[property], options),\n                                expressions: {\n                                    hide: (f) => !f.model || isEmpty(f.model[property]),\n                                },\n                            });\n                        }\n                    }\n                });\n                if (schema.oneOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, shareFormControl: false }));\n                }\n                if (schema.anyOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('anyOf', schema.anyOf, options));\n                }\n                break;\n            }\n            case 'array': {\n                if (schema.hasOwnProperty('minItems')) {\n                    field.props.minItems = schema.minItems;\n                    this.addValidator(field, 'minItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        return isEmpty(value) || value.length >= schema.minItems;\n                    });\n                    if (!options.isOptional && schema.minItems > 0 && field.defaultValue === undefined) {\n                        field.defaultValue = Array.from(new Array(schema.minItems));\n                    }\n                }\n                if (schema.hasOwnProperty('maxItems')) {\n                    field.props.maxItems = schema.maxItems;\n                    this.addValidator(field, 'maxItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        return isEmpty(value) || value.length <= schema.maxItems;\n                    });\n                }\n                if (schema.hasOwnProperty('uniqueItems')) {\n                    field.props.uniqueItems = schema.uniqueItems;\n                    this.addValidator(field, 'uniqueItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        if (isEmpty(value) || !schema.uniqueItems) {\n                            return true;\n                        }\n                        const uniqueItems = Array.from(new Set(value.map((v) => JSON.stringify(v))));\n                        return uniqueItems.length === value.length;\n                    });\n                }\n                // resolve items schema needed for isEnum check\n                if (schema.items && !Array.isArray(schema.items)) {\n                    schema.items = this.resolveSchema(schema.items, options);\n                }\n                // TODO: remove isEnum check once adding an option to skip extension\n                if (!this.isEnum(schema)) {\n                    field.fieldArray = (root) => {\n                        if (!Array.isArray(schema.items)) {\n                            // When items is a single schema, the additionalItems keyword is meaningless, and it should not be used.\n                            const f = schema.items ? this._toFieldConfig(schema.items, options) : {};\n                            if (f.props) {\n                                f.props.required = true;\n                            }\n                            return f;\n                        }\n                        const length = root.fieldGroup ? root.fieldGroup.length : 0;\n                        const itemSchema = schema.items[length] ? schema.items[length] : schema.additionalItems;\n                        const f = itemSchema ? this._toFieldConfig(itemSchema, options) : {};\n                        if (f.props) {\n                            f.props.required = true;\n                        }\n                        if (schema.items[length]) {\n                            f.props.removable = false;\n                        }\n                        return f;\n                    };\n                }\n                break;\n            }\n        }\n        if (schema.hasOwnProperty('const')) {\n            field.props.const = schema.const;\n            this.addValidator(field, 'const', ({ value }) => value === schema.const);\n            if (!field.type) {\n                field.defaultValue = schema.const;\n            }\n        }\n        if (this.isEnum(schema)) {\n            field.props.multiple = field.type === 'array';\n            field.type = 'enum';\n            field.props.options = this.toEnumOptions(schema);\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        // map in possible formlyConfig options from the widget property\n        if (schema.widget?.formlyConfig) {\n            field = this.mergeFields(field, schema.widget.formlyConfig);\n        }\n        field.templateOptions = field.props;\n        // if there is a map function passed in, use it to allow the user to\n        // further customize how fields are being mapped\n        return options.map ? options.map(field, schema) : field;\n    }\n    resolveSchema(schema, options) {\n        if (schema && schema.$ref) {\n            schema = this.resolveDefinition(schema, options);\n        }\n        if (schema && schema.allOf) {\n            schema = this.resolveAllOf(schema, options);\n        }\n        return schema;\n    }\n    resolveAllOf({ allOf, ...baseSchema }, options) {\n        if (!allOf.length) {\n            throw Error(`allOf array can not be empty ${allOf}.`);\n        }\n        return allOf.reduce((base, schema) => {\n            schema = this.resolveSchema(schema, options);\n            if (base.required && schema.required) {\n                base.required = [...base.required, ...schema.required];\n            }\n            if (schema.uniqueItems) {\n                base.uniqueItems = schema.uniqueItems;\n            }\n            // resolve to min value\n            ['maxLength', 'maximum', 'exclusiveMaximum', 'maxItems', 'maxProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] < schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            // resolve to max value\n            ['minLength', 'minimum', 'exclusiveMinimum', 'minItems', 'minProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] > schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            return ɵreverseDeepMerge(base, schema);\n        }, baseSchema);\n    }\n    resolveMultiSchema(mode, schemas, options) {\n        return {\n            type: 'multischema',\n            fieldGroup: [\n                {\n                    type: 'enum',\n                    defaultValue: -1,\n                    props: {\n                        multiple: mode === 'anyOf',\n                        options: schemas.map((s, i) => ({ label: s.title, value: i, disabled: s.readOnly })),\n                    },\n                    hooks: {\n                        onInit: (f) => f.formControl.valueChanges.pipe(tap(() => f.options.detectChanges(f.parent))),\n                    },\n                },\n                {\n                    fieldGroup: schemas.map((s, i) => ({\n                        ...this._toFieldConfig(s, { ...options, resetOnHide: true }),\n                        expressions: {\n                            hide: (f, forceUpdate) => {\n                                const control = f.parent.parent.fieldGroup[0].formControl;\n                                if (control.value === -1 || forceUpdate) {\n                                    let value = f.parent.fieldGroup\n                                        .map((f, i) => [f, i, this.isFieldValid(f, i, schemas, options)])\n                                        .sort(([f1, , f1Valid], [f2, , f2Valid]) => {\n                                        if (f1Valid !== f2Valid) {\n                                            return f2Valid ? 1 : -1;\n                                        }\n                                        const matchedFields1 = totalMatchedFields(f1);\n                                        const matchedFields2 = totalMatchedFields(f2);\n                                        if (matchedFields1 === matchedFields2) {\n                                            if (f1.props.disabled === f2.props.disabled) {\n                                                return 0;\n                                            }\n                                            return matchedFields2 > matchedFields1 ? 1 : -1;\n                                        }\n                                        return matchedFields2 > matchedFields1 ? 1 : -1;\n                                    })\n                                        .map(([, i]) => i);\n                                    if (mode === 'anyOf') {\n                                        const definedValue = value.filter((i) => totalMatchedFields(f.parent.fieldGroup[i]));\n                                        value = definedValue.length > 0 ? definedValue : [value[0] || 0];\n                                    }\n                                    value = value.length > 0 ? value : [0];\n                                    control.setValue(mode === 'anyOf' ? value : value[0]);\n                                }\n                                return Array.isArray(control.value) ? control.value.indexOf(i) === -1 : control.value !== i;\n                            },\n                        },\n                    })),\n                },\n            ],\n        };\n    }\n    resolveDefinition(schema, options) {\n        const [uri, pointer] = schema.$ref.split('#/');\n        if (uri) {\n            throw Error(`Remote schemas for ${schema.$ref} not supported yet.`);\n        }\n        const definition = !pointer\n            ? null\n            : pointer\n                .split('/')\n                .reduce((def, path) => (def?.hasOwnProperty(path) ? def[path] : null), options.schema);\n        if (!definition) {\n            throw Error(`Cannot find a definition for ${schema.$ref}.`);\n        }\n        if (definition.$ref) {\n            return this.resolveDefinition(definition, options);\n        }\n        return {\n            ...definition,\n            ...['title', 'description', 'default', 'widget'].reduce((annotation, p) => {\n                if (schema.hasOwnProperty(p)) {\n                    annotation[p] = schema[p];\n                }\n                return annotation;\n            }, {}),\n        };\n    }\n    resolveDependencies(schema) {\n        const propDeps = {};\n        const schemaDeps = {};\n        Object.keys(schema.dependencies || {}).forEach((prop) => {\n            const dependency = schema.dependencies[prop];\n            if (Array.isArray(dependency)) {\n                // Property dependencies\n                dependency.forEach((dep) => {\n                    if (!propDeps[dep]) {\n                        propDeps[dep] = [prop];\n                    }\n                    else {\n                        propDeps[dep].push(prop);\n                    }\n                });\n            }\n            else {\n                // schema dependencies\n                schemaDeps[prop] = dependency;\n            }\n        });\n        return { propDeps, schemaDeps };\n    }\n    guessSchemaType(schema) {\n        const type = schema?.type;\n        if (!type && schema?.properties) {\n            return ['object'];\n        }\n        if (Array.isArray(type)) {\n            if (type.length === 1) {\n                return type;\n            }\n            if (type.length === 2 && type.indexOf('null') !== -1) {\n                return type.sort((t1) => (t1 == 'null' ? 1 : -1));\n            }\n            return type;\n        }\n        return type ? [type] : [];\n    }\n    addValidator(field, name, validator) {\n        field.validators = field.validators || {};\n        field.validators[name] = validator;\n    }\n    isEnum(schema) {\n        return (!!schema.enum ||\n            (schema.anyOf && schema.anyOf.every(isConst)) ||\n            (schema.oneOf && schema.oneOf.every(isConst)) ||\n            (schema.uniqueItems && schema.items && !Array.isArray(schema.items) && this.isEnum(schema.items)));\n    }\n    toEnumOptions(schema) {\n        if (schema.enum) {\n            return schema.enum.map((value) => ({ value, label: value }));\n        }\n        const toEnum = (s) => {\n            const value = s.hasOwnProperty('const') ? s.const : s.enum[0];\n            const option = { value, label: s.title || value };\n            if (s.readOnly) {\n                option.disabled = true;\n            }\n            return option;\n        };\n        if (schema.anyOf) {\n            return schema.anyOf.map(toEnum);\n        }\n        if (schema.oneOf) {\n            return schema.oneOf.map(toEnum);\n        }\n        return this.toEnumOptions(schema.items);\n    }\n    isFieldValid(root, i, schemas, options) {\n        if (!root._schemasFields) {\n            Object.defineProperty(root, '_schemasFields', { enumerable: false, writable: true, configurable: true });\n            root._schemasFields = {};\n        }\n        let field = root._schemasFields[i];\n        const model = root.model ? ɵclone(root.model) : root.fieldArray ? [] : {};\n        if (!field) {\n            field = root._schemasFields[i] = root.options.build({\n                form: Array.isArray(model) ? new FormArray([]) : new FormGroup({}),\n                fieldGroup: [\n                    this._toFieldConfig(schemas[i], {\n                        ...options,\n                        resetOnHide: true,\n                        ignoreDefault: true,\n                        map: null,\n                        strict: true,\n                    }),\n                ],\n                model,\n                options: {},\n            });\n        }\n        else {\n            field.model = model;\n            root.options.build(field);\n        }\n        return field.form.valid;\n    }\n    mergeFields(f1, f2) {\n        for (let prop in f2) {\n            const f1Prop = prop === 'templateOptions' ? 'props' : prop;\n            if (isObject(f1[f1Prop]) && isObject(f2[prop])) {\n                f1[f1Prop] = this.mergeFields(f1[f1Prop], f2[prop]);\n            }\n            else if (f2[prop] != null) {\n                f1[f1Prop] = f2[prop];\n            }\n        }\n        return f1;\n    }\n}\nFormlyJsonschema.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nFormlyJsonschema.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormlyJsonschema };\n"],"x_google_ignoreList":[0]}