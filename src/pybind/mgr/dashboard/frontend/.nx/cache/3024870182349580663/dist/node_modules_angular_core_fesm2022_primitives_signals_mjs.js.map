{"version":3,"file":"node_modules_angular_core_fesm2022_primitives_signals_mjs.js","mappings":"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","names":["defaultEquals","a","b","Object","is","activeConsumer","inNotificationPhase","epoch","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","idx","assertConsumerNode","length","consumerIsLive","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","i","pop","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","isConsumerNode","push","lastIdx","idxProducer","createComputed","computation","create","COMPUTED_NODE","computed","ERRORED","error","UNSET","COMPUTING","equal","oldValue","newValue","err","throwInvalidWriteToSignalErrorFn","defaultThrowError","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","fn","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","setPostSignalSetFn","signalSetFn","signalValueChanged","signalUpdateFn","updater","runPostSignalSetFn","createWatch","schedule","allowSignalWrites","WATCH_NODE","registerOnCleanup","cleanupFn","ref","notify","run","hasRun","NOOP_CLEANUP_FN","cleanup","destroy","destroyWatchNode","isWatchNodeDestroyed","c","setAlternateWeakRefImpl","impl"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/core/fesm2022/primitives/signals.mjs"],"sourcesContent":["/**\n * @license Angular v18.2.11\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer)\n            ? producerAddLiveConsumer(node, activeConsumer, idx)\n            : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        node.dirty = false;\n        node.lastCleanEpoch = epoch;\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node ||\n        node.producerNode === undefined ||\n        node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length =\n        node.producerLastReadVersion.length =\n            node.producerIndexOfThis.length =\n                0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n    return node.producerNode !== undefined;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                newValue = node.computation();\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET &&\n                oldValue !== ERRORED &&\n                newValue !== ERRORED &&\n                node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    const getter = (() => {\n        producerAccessed(node);\n        return node.value;\n    });\n    getter[SIGNAL] = node;\n    return getter;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn() {\n    producerAccessed(this);\n    return this.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn() {\n    postSignalSetFn?.();\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nexport { REACTIVE_NODE, SIGNAL, SIGNAL_NODE, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, createWatch, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostSignalSetFn, setActiveConsumer, setAlternateWeakRefImpl, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalSetFn, signalUpdateFn };\n"],"x_google_ignoreList":[0]}