{"version":3,"file":"node_modules_carbon-components-angular_fesm2020_carbon-components-angular-utils_mjs.js","mappings":"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","names":["_a","PLACEMENTS","LEFT","RIGHT","TOP","BOTTOM","defaultPositions","referenceOffset","target","referenceRect","top","Math","round","offsetHeight","height","left","offsetWidth","width","windowRef","window","innerHeight","scrollY","innerWidth","scrollX","Position","positions","this","Object","assign","prototype","getRelativeOffset","offsets","offsetLeft","offsetTop","offsetParent","getComputedStyle","position","getAbsoluteOffset","currentNode","margins","computed","marginLeft","marginTop","parseInt","targetRect","getBoundingClientRect","relativeRect","document","body","findRelative","reference","placement","calculatePosition","findAbsolute","findPosition","offsetFunction","bind","findPositionAt","offset","getPlacementBox","targetBottom","targetRight","bottom","right","addOffset","setElement","element","style","findBestPlacement","placements","containerFunction","positionFunction","_this","defaultContainerFunction","weightedPlacements","map","pos","box","hiddenHeight","hiddenWidth","container","area","weight","sort","a","b","findBestPlacementAt","_","console","error","__WEBPACK_DEFAULT_EXPORT__","findSiblingElem","direction","classList","contains","findNextElem","findPrevElem","HcModeChecker","htmlChecker","createElement","add","appendChild","backgroundColor","toString","removeChild","focusNextTree","elem","rootElem","focusable","querySelector","focus","focusNextElem","nextElem","nextElementSibling","focusableElem","nextRootElem","focusPrevElem","parentRef","prevElem","previousElementSibling","getAttribute","lastFocElms","querySelectorAll","i","length","getClientRects","AnimationFrameServiceSingleton","constructor","ngZone","frameSource","Subject","tick","asObservable","runOutsideAngular","animationFrameId","requestAnimationFrame","doTick","ngOnDestroy","cancelAnimationFrame","frame","next","ɵfac","__ngFactoryType__","i0","ɵprov","token","factory","AnimationFrameService","singleton","from","merge","objects","object","key","hasOwnProperty","isScrollableElement","computedStyle","overflow","isVisibleInContainer","elementRect","containerRect","tagName","isAboveViewport","clientHeight","isLeftOfViewport","isBelowViewport","documentElement","isRightOfViewport","clientWidth","getScrollableParents","node","elements","parentElement","push","hasScrollableParents","scrollableParentsObservable","observables","fromEvent","passive","pipe","event","merge$1","clone","obj","JSON","parse","stringify","matchesAttr","el","attr","val","styles","includes","closestAttr","s","t","parentNode","nodeType","ElementService","visibility","scrollableParents","parent","visible","getEventObservable","targetElement","eventType","DocumentService","globalEvents","Map","documentRef","subscriptions","Subscription","handleEvent","callback","has","set","Observable","observable","get","subscribe","handleClick","unsubscribe","EventService","documentService","targets","WeakMap","on","eventMap","subscription","onDocument","DOCUMENT_SERVICE_PROVIDER_FACTORY","parentService","DOCUMENT_SERVICE_PROVIDER","provide","deps","Optional","SkipSelf","useFactory","ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY","ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER","NgZone","UtilsModule","ɵmod","type","ɵinj","providers","_scrollbarWidth","getScrollbarWidth","outer","msOverflowStyle","widthNoScroll","inner","widthWithScroll"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/carbon-components-angular/node_modules/@carbon/utils-position/index.js","./node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs"],"sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\nvar _a;\nexport var PLACEMENTS;\n(function (PLACEMENTS) {\n    PLACEMENTS[\"LEFT\"] = \"left\";\n    PLACEMENTS[\"RIGHT\"] = \"right\";\n    PLACEMENTS[\"TOP\"] = \"top\";\n    PLACEMENTS[\"BOTTOM\"] = \"bottom\";\n})(PLACEMENTS || (PLACEMENTS = {}));\nexport var defaultPositions = (_a = {},\n    _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left - target.offsetWidth)\n    }); },\n    _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left + referenceRect.width)\n    }); },\n    _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top - target.offsetHeight),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top + referenceRect.height),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a);\nvar windowRef = typeof window !== \"undefined\" ? window : {\n    innerHeight: 0,\n    scrollY: 0,\n    innerWidth: 0,\n    scrollX: 0\n};\nvar Position = /** @class */ (function () {\n    function Position(positions) {\n        if (positions === void 0) { positions = {}; }\n        this.positions = defaultPositions;\n        this.positions = Object.assign({}, defaultPositions, positions);\n    }\n    Position.prototype.getRelativeOffset = function (target) {\n        // start with the initial element offsets\n        var offsets = {\n            left: target.offsetLeft,\n            top: target.offsetTop\n        };\n        // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n        while (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n            offsets.left += target.offsetLeft;\n            offsets.top += target.offsetTop;\n            target = target.offsetParent;\n        }\n        return offsets;\n    };\n    Position.prototype.getAbsoluteOffset = function (target) {\n        var currentNode = target;\n        var margins = {\n            top: 0,\n            left: 0\n        };\n        // searches for containing elements with additional margins\n        while (currentNode.offsetParent) {\n            var computed = getComputedStyle(currentNode.offsetParent);\n            // find static elements with additional margins\n            // since they tend to throw off our positioning\n            // (usually this is just the body)\n            if (computed.position === \"static\" &&\n                computed.marginLeft &&\n                computed.marginTop) {\n                if (parseInt(computed.marginTop, 10)) {\n                    margins.top += parseInt(computed.marginTop, 10);\n                }\n                if (parseInt(computed.marginLeft, 10)) {\n                    margins.left += parseInt(computed.marginLeft, 10);\n                }\n            }\n            currentNode = currentNode.offsetParent;\n        }\n        var targetRect = target.getBoundingClientRect();\n        var relativeRect = document.body.getBoundingClientRect();\n        return {\n            top: targetRect.top - relativeRect.top + margins.top,\n            left: targetRect.left - relativeRect.left + margins.left\n        };\n    };\n    // finds the position relative to the `reference` element\n    Position.prototype.findRelative = function (reference, target, placement) {\n        var referenceOffset = this.getRelativeOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findAbsolute = function (reference, target, placement) {\n        var referenceOffset = this.getAbsoluteOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {\n        if (offsetFunction === void 0) { offsetFunction = this.getAbsoluteOffset.bind(this); }\n        var referenceOffset = offsetFunction(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPositionAt = function (offset, target, placement) {\n        return this.calculatePosition(offset, { top: 0, left: 0, height: 0, width: 0 }, target, placement);\n    };\n    /**\n     * Get the dimensions of an element from an AbsolutePosition and a reference element\n     */\n    Position.prototype.getPlacementBox = function (target, position) {\n        var targetBottom = target.offsetHeight + position.top;\n        var targetRight = target.offsetWidth + position.left;\n        return {\n            top: position.top,\n            bottom: targetBottom,\n            left: position.left,\n            right: targetRight\n        };\n    };\n    Position.prototype.addOffset = function (position, top, left) {\n        if (top === void 0) { top = 0; }\n        if (left === void 0) { left = 0; }\n        return Object.assign({}, position, {\n            top: position.top + top,\n            left: position.left + left\n        });\n    };\n    Position.prototype.setElement = function (element, position) {\n        element.style.top = position.top + \"px\";\n        element.style.left = position.left + \"px\";\n    };\n    Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }\n        if (positionFunction === void 0) { positionFunction = this.findPosition.bind(this); }\n        /**\n         * map over the array of placements and weight them based on the percentage of visible area\n         * where visible area is defined as the area not obscured by the window borders\n         */\n        var weightedPlacements = placements.map(function (placement) {\n            var pos = positionFunction(reference, target, placement);\n            var box = _this.getPlacementBox(target, pos);\n            var hiddenHeight = 0;\n            var hiddenWidth = 0;\n            var container = containerFunction();\n            // the element is exceeding from top or bottom of its container\n            if (box.top < container.top) {\n                hiddenHeight = container.top - box.top;\n            }\n            else if (box.bottom > container.height) {\n                hiddenHeight = box.bottom - container.height;\n            }\n            // the element is exceeding from left or right of its container\n            if (box.left < container.left) {\n                hiddenWidth = container.left - box.left;\n            }\n            else if (box.right > container.width) {\n                hiddenWidth = box.right - container.width;\n            }\n            // if one of the hidden dimensions is 0 but the other is > 0\n            // we want to have a positive area, so setting the null one to 1\n            if (hiddenHeight && !hiddenWidth) {\n                hiddenWidth = 1;\n            }\n            else if (hiddenWidth && !hiddenHeight) {\n                hiddenHeight = 1;\n            }\n            var area = target.offsetHeight * target.offsetWidth;\n            var hiddenArea = hiddenHeight * hiddenWidth;\n            // if visibleArea is 0 it means the element is fully outside container bounds\n            // and visiblePercent will then be 0\n            var visibleArea = area - hiddenArea;\n            var visiblePercent = visibleArea / area;\n            return {\n                placement: placement,\n                weight: visiblePercent\n            };\n        });\n        // sort the placements from best to worst\n        weightedPlacements.sort(function (a, b) { return b.weight - a.weight; });\n        // pick the best!\n        return weightedPlacements[0].placement;\n    };\n    Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }\n        var positionAt = function (_, target, placement) {\n            return _this.findPositionAt(offset, target, placement);\n        };\n        return this.findBestPlacement(null, target, placements, containerFunction, positionAt);\n    };\n    Position.prototype.defaultContainerFunction = function () {\n        return {\n            // we go with window here, because that's going to be the simple/common case\n            top: 0,\n            left: 0,\n            height: windowRef.innerHeight,\n            width: windowRef.innerWidth\n        };\n    };\n    Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {\n        if (this.positions[placement]) {\n            return this.positions[placement](referenceOffset, target, referenceRect);\n        }\n        console.error(\"No function found for placement, defaulting to 0,0\");\n        return { left: 0, top: 0 };\n    };\n    return Position;\n}());\nexport { Position };\nexport var position = new Position();\nexport default Position;\n","import * as i0 from '@angular/core';\nimport { Injectable, Optional, SkipSelf, NgZone, NgModule } from '@angular/core';\nimport { Subject, from, fromEvent, merge as merge$1, Subscription, Observable } from 'rxjs';\nexport { PLACEMENTS, Position, defaultPositions, position } from '@carbon/utils-position';\nimport { map } from 'rxjs/operators';\n\nfunction findSiblingElem(target, direction) {\n    if (target[direction]) {\n        if (target[direction].classList.contains(\"disabled\")) {\n            return findSiblingElem(target[direction], direction);\n        }\n        return target[direction];\n    }\n}\nfunction findNextElem(target) {\n    return findSiblingElem(target, \"nextElementSibling\");\n}\nfunction findPrevElem(target) {\n    return findSiblingElem(target, \"previousElementSibling\");\n}\n// check for Hight contrast mode\nfunction HcModeChecker() {\n    let colorTest = \"rgb(255, 0, 0)\";\n    let htmlChecker = document.createElement(\"div\");\n    htmlChecker.classList.add(\"hc-checker\");\n    document.body.appendChild(htmlChecker);\n    if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {\n        document.body.classList.add(\"a11y\");\n    }\n    document.body.removeChild(htmlChecker);\n}\nfunction focusNextTree(elem, rootElem = null) {\n    if (elem) {\n        let focusable = elem.querySelector(\"[tabindex='0']\");\n        if (focusable) {\n            focusable.focus();\n        }\n        else {\n            focusNextElem(elem, rootElem);\n        }\n    }\n}\nfunction focusNextElem(elem, rootElem = null) {\n    if (elem) {\n        let nextElem = elem.nextElementSibling;\n        if (nextElem) {\n            let focusableElem = nextElem.querySelector(\"[tabindex='0']\");\n            if (focusableElem) {\n                focusableElem.focus();\n            }\n            else {\n                focusNextElem(nextElem, rootElem);\n            }\n        }\n        else {\n            if (rootElem) {\n                let nextRootElem = rootElem.nextElementSibling;\n                if (nextRootElem) {\n                    focusNextTree(nextRootElem, rootElem);\n                }\n            }\n        }\n    }\n}\nfunction focusPrevElem(elem, parentRef = null) {\n    if (elem) {\n        let prevElem = elem.previousElementSibling;\n        if (prevElem) {\n            let focusableElem = prevElem.querySelector(\"[tabindex='0']\");\n            if (focusableElem) {\n                if (focusableElem.getAttribute(\"aria-expanded\") === \"true\") {\n                    let lastFocElms = prevElem.querySelectorAll(\"[tabindex='0']\");\n                    let arrLen = lastFocElms.length - 1;\n                    for (let i = arrLen; i >= 0; i--) {\n                        if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight ||\n                            lastFocElms[i].getClientRects().length)) {\n                            focusableElem = lastFocElms[i];\n                            break;\n                        }\n                    }\n                }\n                focusableElem.focus();\n            }\n            else {\n                focusPrevElem(prevElem, parentRef);\n            }\n        }\n        else {\n            if (parentRef) {\n                parentRef.querySelector(\"[tabindex='0']\").focus();\n            }\n        }\n    }\n}\n\nclass AnimationFrameServiceSingleton {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.frameSource = new Subject();\n        this.tick = this.frameSource.asObservable();\n        this.ngZone.runOutsideAngular(() => {\n            this.animationFrameId = requestAnimationFrame(this.doTick.bind(this));\n        });\n    }\n    ngOnDestroy() {\n        cancelAnimationFrame(this.animationFrameId);\n    }\n    doTick(frame) {\n        this.frameSource.next(frame);\n        this.ngZone.runOutsideAngular(() => {\n            requestAnimationFrame(this.doTick.bind(this));\n        });\n    }\n}\nAnimationFrameServiceSingleton.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameServiceSingleton, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\nAnimationFrameServiceSingleton.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameServiceSingleton });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameServiceSingleton, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\nclass AnimationFrameService {\n    constructor(singleton) {\n        this.singleton = singleton;\n        this.tick = from(this.singleton.tick);\n    }\n}\nAnimationFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameService, deps: [{ token: AnimationFrameServiceSingleton }], target: i0.ɵɵFactoryTarget.Injectable });\nAnimationFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: AnimationFrameService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: AnimationFrameServiceSingleton }]; } });\n\n// custom deep object merge\nconst merge = (target, ...objects) => {\n    for (const object of objects) {\n        for (const key in object) {\n            if (object.hasOwnProperty(key)) {\n                // since we're dealing just with JSON this simple check should be enough\n                if (object[key] instanceof Object) {\n                    if (!target[key]) {\n                        target[key] = {};\n                    }\n                    // recursively merge into the target\n                    // most translations only run 3 or 4 levels deep, so no stack explosions\n                    target[key] = merge(target[key], object[key]);\n                }\n                else {\n                    target[key] = object[key];\n                }\n            }\n        }\n    }\n    return target;\n};\n\n/**\n * Checks if a given element is scrollable.\n * If the element has an overflow set as part of its computed style it can scroll.\n * @param element the element to check scrollability\n */\nconst isScrollableElement = (element) => {\n    const computedStyle = getComputedStyle(element);\n    return (computedStyle.overflow === \"auto\" ||\n        computedStyle.overflow === \"scroll\" ||\n        computedStyle[\"overflow-y\"] === \"auto\" ||\n        computedStyle[\"overflow-y\"] === \"scroll\" ||\n        computedStyle[\"overflow-x\"] === \"auto\" ||\n        computedStyle[\"overflow-x\"] === \"scroll\");\n};\n/**\n * Checks if an element is visible within a container\n * @param element the element to check\n * @param container the container to check\n */\nconst isVisibleInContainer = (element, container) => {\n    const elementRect = element.getBoundingClientRect();\n    const containerRect = container.getBoundingClientRect();\n    // If there exists `height: 100%` on the `html` or `body` tag of an application,\n    // it causes the calculation to return true if you need to scroll before the element is seen.\n    // In that case we calculate its visibility based on the window viewport.\n    if (container.tagName === \"BODY\" || container.tagName === \"HTML\") {\n        // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in\n        // the screen. This also takes into account partial visibility of an element.\n        const isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;\n        const isLeftOfViewport = elementRect.left < 0;\n        const isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);\n        const isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);\n        const isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);\n        return isVisibleInViewport;\n    }\n    return (\n    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.\n    (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&\n        elementRect.top >= (-element.clientHeight));\n};\nconst getScrollableParents = (node) => {\n    const elements = [document.body];\n    while (node.parentElement && node !== document.body) {\n        if (isScrollableElement(node)) {\n            elements.push(node);\n        }\n        node = node.parentElement;\n    }\n    return elements;\n};\nconst hasScrollableParents = (node) => {\n    while (node.parentElement && node !== document.body) {\n        if (isScrollableElement(node)) {\n            return true;\n        }\n        node = node.parentElement;\n    }\n    return false;\n};\n/**\n * Returns an observable that emits whenever any scrollable parent element scrolls\n *\n * @param node root element to start finding scrolling parents from\n */\nconst scrollableParentsObservable = (node) => {\n    const windowScroll = fromEvent(window, \"scroll\", { passive: true }).pipe(map(event => \n    // update the event target to be something useful. In this case `body` is a sensible replacement\n    Object.assign({}, event, { target: document.body })));\n    let observables = [windowScroll];\n    // walk the parents and subscribe to all the scroll events we can\n    while (node.parentElement && node !== document.body) {\n        if (isScrollableElement(node)) {\n            observables.push(fromEvent(node, \"scroll\", { passive: true }));\n        }\n        node = node.parentElement;\n    }\n    return merge$1(...observables);\n};\n\nfunction clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction matchesAttr(el, attr, val) {\n    const styles = window.getComputedStyle(el);\n    return val.includes(styles[attr]);\n}\nfunction closestAttr(s, t, element) {\n    let el = element;\n    if (!element) {\n        return null;\n    }\n    do {\n        if (matchesAttr(el, s, t)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n}\n\nclass ElementService {\n    constructor(singleton) {\n        this.singleton = singleton;\n        this.tick = from(this.singleton.tick);\n    }\n    visibility(target, parentElement = target) {\n        const scrollableParents = getScrollableParents(parentElement);\n        return this.tick.pipe(map(() => {\n            for (const parent of scrollableParents) {\n                if (!isVisibleInContainer(target, parent)) {\n                    return {\n                        visible: false\n                    };\n                }\n            }\n            return {\n                visible: true\n            };\n        }));\n    }\n}\nElementService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: ElementService, deps: [{ token: AnimationFrameServiceSingleton }], target: i0.ɵɵFactoryTarget.Injectable });\nElementService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: ElementService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: ElementService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: AnimationFrameServiceSingleton }]; } });\n\nconst getEventObservable = (targetElement, eventType) => {\n    switch (eventType) {\n        case \"scroll\":\n        case \"resize\":\n        case \"touchstart\":\n        case \"touchmove\":\n        case \"touchend\":\n            return fromEvent(targetElement, eventType, { passive: true });\n        default:\n            return fromEvent(targetElement, eventType);\n    }\n};\n\nclass DocumentService {\n    constructor() {\n        this.globalEvents = new Map();\n        this.documentRef = document;\n        this.subscriptions = new Subscription();\n    }\n    handleEvent(eventType, callback) {\n        if (!this.globalEvents.has(eventType)) {\n            if (this.documentRef) {\n                this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));\n            }\n            else {\n                this.globalEvents.set(eventType, new Observable());\n            }\n        }\n        const observable = this.globalEvents.get(eventType);\n        this.subscriptions.add(observable.subscribe(callback));\n    }\n    handleClick(callback) {\n        this.handleEvent(\"click\", callback);\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n        this.globalEvents = null;\n    }\n}\nDocumentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: DocumentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDocumentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: DocumentService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: DocumentService, decorators: [{\n            type: Injectable\n        }] });\n\nclass EventService {\n    constructor(documentService) {\n        this.documentService = documentService;\n        this.subscriptions = new Subscription();\n        this.targets = new WeakMap();\n    }\n    on(targetElement, eventType, callback) {\n        if (!this.targets.has(targetElement)) {\n            this.targets.set(targetElement, new Map());\n        }\n        const eventMap = this.targets.get(targetElement);\n        if (!eventMap.has(eventType)) {\n            eventMap.set(eventType, getEventObservable(targetElement, eventType));\n        }\n        const subscription = eventMap.get(eventType).subscribe(callback);\n        this.subscriptions.add(subscription);\n    }\n    onDocument(eventType, callback) {\n        this.documentService.handleEvent(eventType, callback);\n    }\n    ngOnDestroy() {\n        this.subscriptions.unsubscribe();\n    }\n}\nEventService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: EventService, deps: [{ token: DocumentService }], target: i0.ɵɵFactoryTarget.Injectable });\nEventService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: EventService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: EventService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: DocumentService }]; } });\n\n// either provides a new instance of DocumentService, or returns the parent\nfunction DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {\n    return parentService || new DocumentService();\n}\n// DocumentService *must* be a singleton to ensure that we handle events and other document level settings once (and only once)\nconst DOCUMENT_SERVICE_PROVIDER = {\n    provide: DocumentService,\n    deps: [[new Optional(), new SkipSelf(), DocumentService]],\n    useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY\n};\n// either provides a new instance of AnimationFrameServiceSingleton, or returns the parent\nfunction ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {\n    return parentService || new AnimationFrameServiceSingleton(ngZone);\n}\n// AnimationFrameServiceSingleton is a singleton so we don't have a ton of duplicate RAFs firing (better for scheduling)\nconst ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {\n    provide: AnimationFrameServiceSingleton,\n    deps: [[new Optional(), new SkipSelf(), AnimationFrameServiceSingleton], NgZone],\n    useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY\n};\nclass UtilsModule {\n}\nUtilsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: UtilsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nUtilsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.3.0\", ngImport: i0, type: UtilsModule });\nUtilsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: UtilsModule, providers: [\n        DOCUMENT_SERVICE_PROVIDER,\n        ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,\n        AnimationFrameServiceSingleton,\n        DocumentService,\n        AnimationFrameService,\n        ElementService,\n        EventService\n    ] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.3.0\", ngImport: i0, type: UtilsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        DOCUMENT_SERVICE_PROVIDER,\n                        ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,\n                        AnimationFrameServiceSingleton,\n                        DocumentService,\n                        AnimationFrameService,\n                        ElementService,\n                        EventService\n                    ]\n                }]\n        }] });\n\nlet _scrollbarWidth = -1;\nfunction getScrollbarWidth() {\n    // lets not recreate this whole thing every time\n    if (_scrollbarWidth >= 0) {\n        return _scrollbarWidth;\n    }\n    // do the calculations the first time\n    const outer = document.createElement(\"div\");\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"100px\";\n    outer.style[\"msOverflowStyle\"] = \"scrollbar\"; // needed for WinJS apps\n    document.body.appendChild(outer);\n    const widthNoScroll = outer.offsetWidth;\n    // force scrollbars\n    outer.style.overflow = \"scroll\";\n    // add innerdiv\n    const inner = document.createElement(\"div\");\n    inner.style.width = \"100%\";\n    outer.appendChild(inner);\n    const widthWithScroll = inner.offsetWidth;\n    // remove divs\n    outer.parentNode.removeChild(outer);\n    _scrollbarWidth = widthNoScroll - widthWithScroll;\n    return _scrollbarWidth;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY, AnimationFrameService, AnimationFrameServiceSingleton, DOCUMENT_SERVICE_PROVIDER, DOCUMENT_SERVICE_PROVIDER_FACTORY, DocumentService, ElementService, EventService, HcModeChecker, UtilsModule, clone, closestAttr, findNextElem, findPrevElem, focusNextElem, focusNextTree, focusPrevElem, getEventObservable, getScrollableParents, getScrollbarWidth, hasScrollableParents, isScrollableElement, isVisibleInContainer, merge, scrollableParentsObservable };\n"],"x_google_ignoreList":[0,1]}