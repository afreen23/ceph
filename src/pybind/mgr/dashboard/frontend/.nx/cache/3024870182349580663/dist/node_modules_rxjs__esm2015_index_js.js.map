{"version":3,"file":"node_modules_rxjs__esm2015_index_js.js","mappings":"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","names":["AnimationFrameAction","AsyncAction","constructor","scheduler","work","super","this","requestAsyncId","id","delay","actions","push","scheduled","requestAnimationFrame","flush","recycleAsyncId","length","cancelAnimationFrame","undefined","AnimationFrameScheduler","AsyncScheduler","action","active","error","index","count","shift","execute","state","unsubscribe","animationFrameScheduler","animationFrame","VirtualTimeScheduler","SchedulerAction","VirtualAction","maxFrames","Number","POSITIVE_INFINITY","frame","frameTimeFactor","schedule","add","sort","sortActions","_execute","a","b","isObservable","obj","Observable","lift","subscribe","bindCallback","callbackFunc","resultSelector","isScheduler","args","pipe","map","isArray","context","subject","params","subscriber","dispatch","AsyncSubject","handler","innerArgs","next","complete","apply","err","canReportError","console","warn","value","dispatchNext","bindNodeCallback","dispatchError","arg","forkJoin","sources","first","forkJoinInternal","isObject","Object","getPrototypeOf","prototype","keys","key","pop","len","values","Array","completed","emitted","i","source","from","hasValue","reduce","result","toString","fromEvent","target","eventName","options","isFunction","setupSubscription","e","arguments","slice","call","sourceObj","isEventTarget","addEventListener","removeEventListener","isJQueryStyleEventEmitter","on","off","isNodeStyleEventEmitter","addListener","removeListener","TypeError","fromEventPattern","addHandler","removeHandler","retValue","generate","initialStateOrOptions","condition","iterate","resultSelectorOrObservable","initialState","identity","conditionResult","closed","needIterate","iif","trueResult","EMPTY","falseResult","defer","interval","period","async","isNumeric","counter","NEVER","noop","never","onErrorResumeNext","remainder","subNext","pairs","subscription","Subscription","hasOwnProperty","partition","predicate","thisArg","filter","subscribeTo","not","range","start","current","using","resourceFactory","observableFactory","resource"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js","./node_modules/rxjs/_esm2015/internal/scheduler/VirtualTimeScheduler.js","./node_modules/rxjs/_esm2015/internal/util/isObservable.js","./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js","./node_modules/rxjs/_esm2015/internal/observable/bindNodeCallback.js","./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js","./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js","./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js","./node_modules/rxjs/_esm2015/internal/observable/generate.js","./node_modules/rxjs/_esm2015/internal/observable/iif.js","./node_modules/rxjs/_esm2015/internal/observable/interval.js","./node_modules/rxjs/_esm2015/internal/observable/never.js","./node_modules/rxjs/_esm2015/internal/observable/onErrorResumeNext.js","./node_modules/rxjs/_esm2015/internal/observable/pairs.js","./node_modules/rxjs/_esm2015/internal/observable/partition.js","./node_modules/rxjs/_esm2015/internal/observable/range.js","./node_modules/rxjs/_esm2015/internal/observable/using.js"],"sourcesContent":["import { AsyncAction } from './AsyncAction';\nexport class AnimationFrameAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport class VirtualTimeScheduler extends AsyncScheduler {\n    constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {\n        super(SchedulerAction, () => this.frame);\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    flush() {\n        const { actions, maxFrames } = this;\n        let error, action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\nVirtualTimeScheduler.frameTimeFactor = 10;\nexport class VirtualAction extends AsyncAction {\n    constructor(scheduler, work, index = scheduler.index += 1) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.active = true;\n        this.index = scheduler.index = index;\n    }\n    schedule(state, delay = 0) {\n        if (!this.id) {\n            return super.schedule(state, delay);\n        }\n        this.active = false;\n        const action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        this.delay = scheduler.frame + delay;\n        const { actions } = scheduler;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        return undefined;\n    }\n    _execute(state, delay) {\n        if (this.active === true) {\n            return super._execute(state, delay);\n        }\n    }\n    static sortActions(a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    }\n}\n","import { Observable } from '../Observable';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isArray } from '../util/isArray';\nimport { isScheduler } from '../util/isScheduler';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(map((args) => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const context = this;\n        let subject;\n        const params = {\n            context,\n            subject,\n            callbackFunc,\n            scheduler,\n        };\n        return new Observable(subscriber => {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                const state = {\n                    args, subscriber, params,\n                };\n                return scheduler.schedule(dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    const self = this;\n    const { args, subscriber, params } = state;\n    const { callbackFunc, context, scheduler } = params;\n    let { subject } = params;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        const handler = (...innerArgs) => {\n            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    const { value, subject } = state;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    const { err, subject } = state;\n    subject.error(err);\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const params = {\n            subject: undefined,\n            args,\n            callbackFunc,\n            scheduler,\n            context: this,\n        };\n        return new Observable(subscriber => {\n            const { context } = params;\n            let { subject } = params;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = params.subject = new AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        const err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                            return;\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { params, subscriber, context });\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    const { params, subscriber, context } = state;\n    const { callbackFunc, args, scheduler } = params;\n    let subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        const handler = (...innerArgs) => {\n            const err = innerArgs.shift();\n            if (err) {\n                this.add(scheduler.schedule(dispatchError, 0, { err, subject }));\n            }\n            else {\n                const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n            }\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            this.add(scheduler.schedule(dispatchError, 0, { err, subject }));\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    const { value, subject } = arg;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    const { err, subject } = arg;\n    subject.error(err);\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { from } from './from';\nexport function forkJoin(...sources) {\n    if (sources.length === 1) {\n        const first = sources[0];\n        if (isArray(first)) {\n            return forkJoinInternal(first, null);\n        }\n        if (isObject(first) && Object.getPrototypeOf(first) === Object.prototype) {\n            const keys = Object.keys(first);\n            return forkJoinInternal(keys.map(key => first[key]), keys);\n        }\n    }\n    if (typeof sources[sources.length - 1] === 'function') {\n        const resultSelector = sources.pop();\n        sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n        return forkJoinInternal(sources, null).pipe(map((args) => resultSelector(...args)));\n    }\n    return forkJoinInternal(sources, null);\n}\nfunction forkJoinInternal(sources, keys) {\n    return new Observable(subscriber => {\n        const len = sources.length;\n        if (len === 0) {\n            subscriber.complete();\n            return;\n        }\n        const values = new Array(len);\n        let completed = 0;\n        let emitted = 0;\n        for (let i = 0; i < len; i++) {\n            const source = from(sources[i]);\n            let hasValue = false;\n            subscriber.add(source.subscribe({\n                next: value => {\n                    if (!hasValue) {\n                        hasValue = true;\n                        emitted++;\n                    }\n                    values[i] = value;\n                },\n                error: err => subscriber.error(err),\n                complete: () => {\n                    completed++;\n                    if (completed === len || !hasValue) {\n                        if (emitted === len) {\n                            subscriber.next(keys ?\n                                keys.reduce((result, key, i) => (result[key] = values[i], result), {}) :\n                                values);\n                        }\n                        subscriber.complete();\n                    }\n                }\n            }));\n        }\n    });\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nconst toString = (() => Object.prototype.toString)();\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable(subscriber => {\n        function handler(e) {\n            if (arguments.length > 1) {\n                subscriber.next(Array.prototype.slice.call(arguments));\n            }\n            else {\n                subscriber.next(e);\n            }\n        }\n        setupSubscription(target, eventName, handler, subscriber, options);\n    });\n}\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n    let unsubscribe;\n    if (isEventTarget(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addEventListener(eventName, handler, options);\n        unsubscribe = () => source.removeEventListener(eventName, handler, options);\n    }\n    else if (isJQueryStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.on(eventName, handler);\n        unsubscribe = () => source.off(eventName, handler);\n    }\n    else if (isNodeStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addListener(eventName, handler);\n        unsubscribe = () => source.removeListener(eventName, handler);\n    }\n    else if (sourceObj && sourceObj.length) {\n        for (let i = 0, len = sourceObj.length; i < len; i++) {\n            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n        }\n    }\n    else {\n        throw new TypeError('Invalid event target');\n    }\n    subscriber.add(unsubscribe);\n}\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isEventTarget(sourceObj) {\n    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nexport function fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable(subscriber => {\n        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);\n        let retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!isFunction(removeHandler)) {\n            return undefined;\n        }\n        return () => removeHandler(handler, retValue);\n    });\n}\n","import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    let resultSelector;\n    let initialState;\n    if (arguments.length == 1) {\n        const options = initialStateOrOptions;\n        initialState = options.initialState;\n        condition = options.condition;\n        iterate = options.iterate;\n        resultSelector = options.resultSelector || identity;\n        scheduler = options.scheduler;\n    }\n    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n        initialState = initialStateOrOptions;\n        resultSelector = identity;\n        scheduler = resultSelectorOrObservable;\n    }\n    else {\n        initialState = initialStateOrOptions;\n        resultSelector = resultSelectorOrObservable;\n    }\n    return new Observable(subscriber => {\n        let state = initialState;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                subscriber,\n                iterate,\n                condition,\n                resultSelector,\n                state\n            });\n        }\n        do {\n            if (condition) {\n                let conditionResult;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return undefined;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            let value;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n        } while (true);\n        return undefined;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, condition } = state;\n    if (subscriber.closed) {\n        return undefined;\n    }\n    if (state.needIterate) {\n        try {\n            state.state = state.iterate(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n    }\n    else {\n        state.needIterate = true;\n    }\n    if (condition) {\n        let conditionResult;\n        try {\n            conditionResult = condition(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!conditionResult) {\n            subscriber.complete();\n            return undefined;\n        }\n        if (subscriber.closed) {\n            return undefined;\n        }\n    }\n    let value;\n    try {\n        value = state.resultSelector(state.state);\n    }\n    catch (err) {\n        subscriber.error(err);\n        return undefined;\n    }\n    if (subscriber.closed) {\n        return undefined;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n        return undefined;\n    }\n    return this.schedule(state);\n}\n","import { defer } from './defer';\nimport { EMPTY } from './empty';\nexport function iif(condition, trueResult = EMPTY, falseResult = EMPTY) {\n    return defer(() => condition() ? trueResult : falseResult);\n}\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period = 0, scheduler = async) {\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(subscriber => {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, counter, period } = state;\n    subscriber.next(counter);\n    this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\nexport const NEVER = new Observable(noop);\nexport function never() {\n    return NEVER;\n}\n","import { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nexport function onErrorResumeNext(...sources) {\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    const [first, ...remainder] = sources;\n    if (sources.length === 1 && isArray(first)) {\n        return onErrorResumeNext(...first);\n    }\n    return new Observable(subscriber => {\n        const subNext = () => subscriber.add(onErrorResumeNext(...remainder).subscribe(subscriber));\n        return from(first).subscribe({\n            next(value) { subscriber.next(value); },\n            error: subNext,\n            complete: subNext,\n        });\n    });\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function pairs(obj, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscriber => {\n            const keys = Object.keys(obj);\n            for (let i = 0; i < keys.length && !subscriber.closed; i++) {\n                const key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    subscriber.next([key, obj[key]]);\n                }\n            }\n            subscriber.complete();\n        });\n    }\n    else {\n        return new Observable(subscriber => {\n            const keys = Object.keys(obj);\n            const subscription = new Subscription();\n            subscription.add(scheduler.schedule(dispatch, 0, { keys, index: 0, subscriber, subscription, obj }));\n            return subscription;\n        });\n    }\n}\nexport function dispatch(state) {\n    const { keys, index, subscriber, subscription, obj } = state;\n    if (!subscriber.closed) {\n        if (index < keys.length) {\n            const key = keys[index];\n            subscriber.next([key, obj[key]]);\n            subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));\n        }\n        else {\n            subscriber.complete();\n        }\n    }\n}\n","import { not } from '../util/not';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { filter } from '../operators/filter';\nimport { Observable } from '../Observable';\nexport function partition(source, predicate, thisArg) {\n    return [\n        filter(predicate, thisArg)(new Observable(subscribeTo(source))),\n        filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))\n    ];\n}\n","import { Observable } from '../Observable';\nexport function range(start = 0, count, scheduler) {\n    return new Observable(subscriber => {\n        if (count === undefined) {\n            count = start;\n            start = 0;\n        }\n        let index = 0;\n        let current = start;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                index, count, start, subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(current++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        return undefined;\n    });\n}\nexport function dispatch(state) {\n    const { start, index, count, subscriber } = state;\n    if (index >= count) {\n        subscriber.complete();\n        return;\n    }\n    subscriber.next(start);\n    if (subscriber.closed) {\n        return;\n    }\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n}\n","import { Observable } from '../Observable';\nimport { from } from './from';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n    return new Observable(subscriber => {\n        let resource;\n        try {\n            resource = resourceFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        let result;\n        try {\n            result = observableFactory(resource);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        const source = result ? from(result) : EMPTY;\n        const subscription = source.subscribe(subscriber);\n        return () => {\n            subscription.unsubscribe();\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}